// This class handles all the data returned from the mesonet API
//
// It is very tightly coupled to the implementation of the page
// generated by clickweather.js
//
// In the past, the data returned by mesonet would only be sent to the charts
// plus a callback to build the legend table. Now the data returned by
// the API is managed by this class (which is persistent and a singleton)
//
// In the future, handling the chart objects may move in here as well

const DATA_TYPES = {
  absolute: 0,
  change: 1,
};

const DATA_TYPES_READABLE = {
  0: "Absolute Reading",
  1: "Change In Reading",
};

const CHART_TYPES = {
  temperature: 0,
  snowDepth: 1,
  windSpeed: 2,
  SWE: 3,
};

const CHART_TYPE_READABLE = {
  0: "Temperature",
  1: "Snow Depth",
  2: "Wind Speed",
  3: "Snow Water Equivalent",
};

const CHART_HEADINGS = ["Temp (f)", "Snow (in)", "Wind (mph)", "SWE (in)"];

const CHART_MODES = {
  local: 0,
  snow: 1,
  custom: 2,
};

// Reverse lookup to put human readable chart modes in the URL
const CHART_MODE_FOR_URL = Object.fromEntries(
  Object.entries(CHART_MODES).map(([key, value]) => [value, key])
);

const STATION_LIST_MODES = { position: 0, stations: 1 };

const CLICK_WEATHER_COLORS = [
  [230, 25, 75], // Red
  [60, 180, 75], // Green
  [255, 225, 25], // Yellow
  [67, 99, 216], // Blue
  [245, 130, 49], // Orange
  [145, 30, 180], // Purple
  [70, 240, 240], // Cyan
  [240, 50, 230], // Magenta
  [188, 246, 12], // Lime
  [250, 190, 190], // Pink
  [0, 128, 128], // Teal
  [230, 190, 255], // Lavender
  [154, 99, 36], // Brown
  [255, 250, 200], // Beige
  [128, 0, 0], // Maroon
  [170, 255, 195], // Mint
  [128, 128, 0], // Olive
  [255, 216, 177], // Peach
  [0, 0, 117], // Navy
  [128, 128, 128], // Gray
];

class clickWeatherManager {
  constructor() {
    if (clickWeatherManager.instance) return clickWeatherManager.instance;
    // Returned data variables
    this.allReturnedStations = [];
    this.allReturnedData = {};

    // Variables for creating different chart types
    this.positionAttributes = {
      stationMode: STATION_LIST_MODES.position,
      position: {},
      stations: [],
    };
    this.definedCharts = [];
    this.definedStations = [];

    this.currentChartMode = CHART_MODES.local;

    // this.stationDataTemplate = [];
    clickWeatherManager.instance = this;
  }

  resetReturnedDataAndStations() {
    this.allReturnedStations = [];
    this.allReturnedData = {};
  }

  setAllStations(newAllStations) {
    this.allReturnedStations = newAllStations;
  }

  addStationData(currentDataSet) {
    var stationArrayIndex = this.allReturnedStations.findIndex(
      (station) => station.stid === currentDataSet.station.stid
    );
    const currentStation = currentDataSet.station;

    // If the station doesn't currently exist,
    // then we need to add it to the station list
    if (stationArrayIndex === -1) {
      this.allReturnedStations.push(currentStation);
      stationArrayIndex = this.allReturnedStations.length - 1;

      this.allReturnedData[stationArrayIndex] = {};

      /*
        station.lat = data.STATION[dataSetIdx].LATITUDE;
        station.lon = data.STATION[dataSetIdx].LONGITUDE;
        station.name = data.STATION[dataSetIdx].NAME;
        station.stid = data.STATION[dataSetIdx].STID;
        station.elevation = data.STATION[dataSetIdx].ELEVATION;
        station.stationType = stationType;
        station.displayOffset 
      // Note the enumeration for stationType is defined in
      // weatherHealper.js as chartTypes
      */

      const stationLocation = {
        lat: parseFloat(currentStation.lat),
        lng: parseFloat(currentStation.lon),
      };

      // The map manager is global
      // I don't love having this tucked in the weather data object
      // Really I should be doing this back in clickweather.js
      // but that part of the script doesn't know about the new-ness of the station
      myMapManager.addMarker(
        stationLocation,
        currentStation.name,
        currentStation.stid,
        CLICK_WEATHER_COLORS[stationArrayIndex]
      );
    }
    // Because this (currentDataSet) is an object that was passed
    // we are actually modifying the source object in this case
    currentDataSet.borderColor = rgbArrayToString(
      CLICK_WEATHER_COLORS[stationArrayIndex]
    );

    var lastDataPoint = currentDataSet.data.length - 1;
    var stationType = currentStation.stationType;

    // Determine offsetIndex based on displayOffset
    var offsetIndex =
      currentStation.displayOffset == true
        ? DATA_TYPES.change
        : DATA_TYPES.absolute;

    /*
    var offsetIndex = 0;
    if (currentStation.displayOffset == true) {
      offsetIndex = 1;
    }
      */

    // First see if the sub arrays exist for the needed data types
    // if they don't initialize them for this station
    // Once that's done, populate the actual data array

    if (!this.allReturnedData[stationArrayIndex][stationType]) {
      this.allReturnedData[stationArrayIndex][stationType] = {};
    }

    if (!this.allReturnedData[stationArrayIndex][stationType][offsetIndex]) {
      this.allReturnedData[stationArrayIndex][stationType][offsetIndex] = [];
    }

    this.allReturnedData[stationArrayIndex][stationType][offsetIndex] =
      currentDataSet.data;
  }

  getStationsWtihAbsDataTypes(stationType) {
    let goodStationIdx = [];

    // console.log(this.allStations);

    this.allReturnedStations.forEach((thisStation, thisIndex) => {
      // console.log("In the loop");
      // console.log(this.allData[thisIndex]);
      if (stationType in this.allReturnedData[thisIndex]) {
        if (
          String(DATA_TYPES.absolute) in
          this.allReturnedData[thisIndex][stationType]
        )
          goodStationIdx.push(thisIndex);
      }
    });

    return goodStationIdx;
  }

  getAbsoluteDataTypes() {
    // This gets the unique keys at the 2nd level where the 3rd level has a key of '0'
    const items = Object.values(this.allReturnedData);

    const keys = items
      .map((obj) => {
        return Object.keys(obj).filter((key) => {
          return obj[key][0] && obj[key][0].hasOwnProperty(0); // Check if key '0' exists at 3rd level
        });
      })
      .flat(); // Flatten the result into a single array of keys

    // Using Set to ensure uniqueness
    return [...new Set(keys)];
  }

  getLatestStationData(stationIndex, stationType) {
    // console.log("station Data get: " + stationIndex + " " + stationType);
    // console.log(this.allData);

    // If the station type doesn't exist, return a blank cell
    if (stationType in this.allReturnedData[stationIndex] == false) {
      return "<td>&nbsp</td>";
    }

    // If the absolute data type (0) doesn't exist, return a blank cell
    if (
      String(DATA_TYPES.absolute) in
        this.allReturnedData[stationIndex][stationType] ==
      false
    ) {
      return "<td>&nbsp</td>";
    }

    const dataSource = this.allReturnedData[stationIndex][stationType][0];

    const lastDataIndex = dataSource.length - 1;

    const lastMeasurementTime = timeUTCToLocalString(
      dataSource[lastDataIndex].x
    );
    const lastMeasurementValue = parseFloat(
      dataSource[lastDataIndex].y
    ).toFixed(0);

    const cellString =
      "<td>" +
      lastMeasurementValue +
      " <sub>" +
      lastMeasurementTime +
      "</sub></td>\n";

    return cellString;
  }

  prepareLegendTable(mapCenter) {
    // Calculate distances and add original index to each station
    const stationsWithDistance = this.allReturnedStations.map(
      (station, index) => {
        const distance = calculateLatLonDistance(
          station.lat,
          station.lon,
          mapCenter.lat,
          mapCenter.lon
        );

        var distance_mi = distance.miles.toFixed(1);
        return { ...station, distance_mi, originalIndex: index };
      }
    );

    // Sort stations based on distance
    stationsWithDistance.sort((a, b) => a.distance_mi - b.distance_mi);
    let legendTableHTML = "";

    legendTableHTML += "<table id='legend-table' border='1' cellpadding='5'>";
    legendTableHTML += "<tr>";

    let headings = [
      "ID",
      "Dist (mi)",
      "Name",
      "Elev (ft)",
      // "Temp (f)",
      // "Snow (in)",
      // "Wind (mph)",
    ];

    let availableStationTypes = this.getAbsoluteDataTypes(this.allReturnedData);

    // Append the specific headings for the data that is present
    availableStationTypes.forEach((stationType) => {
      headings.push(CHART_HEADINGS[stationType]);
    });

    // Iterate over the headings and print each one
    headings.forEach((heading) => {
      legendTableHTML += "<th>" + heading + "</th>";
    });

    legendTableHTML += "</tr>";
    // ("<tr><th>ID</th><th>Dist (mi)</th><th>Name</th><th>Elevation</th></tr>");

    stationsWithDistance.forEach((station, index) => {
      const color = rgbArrayToString(
        CLICK_WEATHER_COLORS[station.originalIndex]
      );

      legendTableHTML += `<tr>`;
      legendTableHTML += `<td style="background-color: ${color};">${station.stid}</td>`;
      legendTableHTML += `<td>${station.distance_mi}</td>`;
      legendTableHTML += `<td>${station.name}</td>`;
      legendTableHTML += `<td>${station.elevation}</td>`;

      availableStationTypes.forEach((stationType) => {
        legendTableHTML += this.getLatestStationData(
          station.originalIndex,
          stationType
        );
      });

      legendTableHTML += "</tr>";
    });

    legendTableHTML += "</table>";

    return legendTableHTML;
  }

  stationChangeAnalysis(stationIdx, stationType, timeHrs) {
    // Check to see if we have absolte or relative data
    // Start with our data type as delta, and then change it to absolute if it exists

    // EDIT - Nevermind, I got rid of even allowing use of change data
    // If we want to do this stuff, we need absolute data
    /* 
    let dataType = 1;
    if ("0" in this.allData[stationIdx][stationType]) {
      dataType = 0;
    }
    */

    const dataType = 0;

    const thisStationData =
      this.allReturnedData[stationIdx][stationType][dataType];

    const lastDataIdx = thisStationData.length - 1;

    const endMeasurement = thisStationData[lastDataIdx].y;
    const endTime = new Date(thisStationData[lastDataIdx].x);

    let maxValue = endMeasurement;
    let minValue = endMeasurement;

    let startValue = 0;
    let finalDataIdx = 0;
    let timeDeltaHours = 0;

    // Iterate backwards over the data set
    for (let dataIdx = lastDataIdx; dataIdx > 0; dataIdx--) {
      // console.log(thisStationData[dataIdx].x);

      const currentTime = new Date(thisStationData[dataIdx].x);
      timeDeltaHours =
        (endTime.getTime() - currentTime.getTime()) / (1000 * 60 * 60);

      /*console.log(
        "idx:" + (lastDataIdx - dataIdx) + " time: " + timeDeltaHours
      );*/
      const currentValue = thisStationData[dataIdx].y;

      if (currentValue > maxValue) {
        maxValue = currentValue;
      }

      if (currentValue < minValue) {
        minValue = currentValue;
      }

      if (timeDeltaHours >= timeHrs) {
        startValue = currentValue;
        finalDataIdx = dataIdx;
        break;
      }
    }

    const thisStation = this.allReturnedStations[stationIdx];

    const results = {
      name: thisStation.name,
      elevation: thisStation.elevation,
      max: maxValue,
      min: minValue,
      startValue: startValue,
      endValue: endMeasurement,
      delta: endMeasurement - startValue,
      numDataPoints: lastDataIdx - finalDataIdx,
      elapsedTime: timeDeltaHours,
    };

    //console.log(results);

    return results;

    // return 0;
  }

  getChangeInData(stationType, timeHrs = 24) {
    const stationList = this.getStationsWtihAbsDataTypes(stationType);
    // console.log("**** STATION LIST ***");
    // console.log(stationList);

    // We'll be pushing objects into this array
    let stationChangeResults = [];
    stationList.forEach((stationIdx) => {
      stationChangeResults.push(
        this.stationChangeAnalysis(stationIdx, stationType, timeHrs)
      );
    });

    /*console.log(stationChangeResults);

    stationChangeResults.sort((a, b) => a.elevation - b.elevation);
    console.log(stationChangeResults);
    */

    return stationChangeResults;
  }

  setChartMode(chartMode) {
    // I might want to validate that I'm not setting this to an incorrect value in the future
    this.currentChartMode = chartMode;
  }

  getChartMode() {
    return this.currentChartMode;
  }

  getCustomChartsToURL() {
    console.log(
      this.definedCharts.map((attr) => encodeURIComponent(attr.title))
    );

    var compactState = this.definedCharts
      .map((currentChart) =>
        [
          encodeURIComponent(currentChart.title),
          currentChart.days,
          +currentChart.offset,
          currentChart.dataType,
          currentChart.radiusMiles,
          currentChart.radiusStations,
          "{" +
            currentChart.tables
              .map((currentTable) => currentTable.hours)
              .join(";") +
            "}",
        ].join(",")
      )
      .join("|");

    console.log(compactState);
    return compactState;
  }

  setCustomChartsFromURL(chartString) {
    const chartStringList = chartString?.split("|") || [chartString];

    console.log(chartStringList);

    // We're limiting to num elements so that the last item can also be a CSV
    const numElements = 7;

    chartStringList.forEach((chartString) => {
      const chartAttributeArray = chartString.split(",");
      if (chartAttributeArray.length != numElements) {
        alert(
          "Incorrectly formatted chart string, each station must have " +
            numElements +
            " attributes comma separated"
        );
        return 0;
      }

      console.log(chartAttributeArray);
      this.setChartMode(CHART_MODES.custom);

      let attributes = {};

      attributes.title = decodeURIComponent(chartAttributeArray[0]);
      attributes.days = parseInt(parseFloat(chartAttributeArray[1]).toFixed(0));

      attributes.offset = false;
      if (parseFloat(chartAttributeArray[2]).toFixed(0) == "1") {
        attributes.offset = true;
      }

      // Create a default value, and allow it to be overriden with a valid parsed value
      attributes.chartType = CHART_TYPES.temperature;
      var parsedChartType = parseInt(chartAttributeArray[3]);

      console.log(parsedChartType);
      // See if the parsed chart type is in the list of valid chart types
      if (Object.values(CHART_TYPES).includes(parsedChartType)) {
        attributes.chartType = parsedChartType;
      }

      attributes.radiusMiles = parseInt(chartAttributeArray[4]);
      attributes.radiusStations = parseInt(chartAttributeArray[5]);

      // Remove the curly braces and check if the result is empty
      const tablesCSV = chartAttributeArray[6].slice(1, -1); // Removes the curly braces

      // If innerCsv is non-empty, split by commas and create an array of objects
      attributes.tables = tablesCSV
        ? tablesCSV.split(";").map((item) => ({ hours: Number(item) }))
        : [];

      this.definedCharts.push(this.createChartObject(attributes));
    });
  }

  createLocalPlots() {
    this.setChartMode(CHART_MODES.local);

    var attributes = {};

    const defaultRadiusMi = 10;
    const defaultRadiusStations = 5;

    // 2 day snow change
    attributes.title = "Snow Change";
    attributes.days = 2;
    attributes.offset = true;
    attributes.chartType = CHART_TYPES.snowDepth;
    attributes.radiusMiles = defaultRadiusMi;
    attributes.radiusStations = defaultRadiusStations;
    attributes.tables = [];

    this.definedCharts.push(this.createChartObject(attributes));

    // Plot 2 day temp
    attributes.title = "Temperature";
    attributes.days = 2;
    attributes.offset = false;
    attributes.chartType = CHART_TYPES.temperature;
    attributes.radiusMiles = defaultRadiusMi;
    attributes.radiusStations = defaultRadiusStations;
    attributes.tables = [];

    this.definedCharts.push(this.createChartObject(attributes));

    // Plot 2 day wind
    attributes.title = "Wind Speed";
    attributes.days = 2;
    attributes.offset = false;
    attributes.chartType = CHART_TYPES.windSpeed;
    attributes.radiusMiles = defaultRadiusMi;
    attributes.radiusStations = defaultRadiusStations;
    attributes.tables = [];

    this.definedCharts.push(this.createChartObject(attributes));
  }

  createFullMountainSuitePlots() {
    this.setChartMode(CHART_MODES.snow);

    var attributes = {};

    const defaultRadiusMi = 20;
    const defaultRadiusStations = 5;

    // Plot 3 day snow change
    attributes.title = "Snow Change";
    attributes.days = 3;
    attributes.offset = true;
    attributes.chartType = CHART_TYPES.snowDepth;
    attributes.radiusMiles = defaultRadiusMi;
    attributes.radiusStations = defaultRadiusStations;
    attributes.tables = [];

    this.definedCharts.push(this.createChartObject(attributes));

    // Plot 2 day temp
    attributes.title = "Temperature";
    attributes.days = 2;
    attributes.offset = false;
    attributes.chartType = CHART_TYPES.temperature;
    attributes.radiusMiles = defaultRadiusMi;
    attributes.radiusStations = defaultRadiusStations;
    attributes.tables = [];

    this.definedCharts.push(this.createChartObject(attributes));

    // Plot 2 day wind
    attributes.title = "Wind Speed";
    attributes.days = 2;
    attributes.offset = false;
    attributes.chartType = CHART_TYPES.windSpeed;
    attributes.radiusMiles = defaultRadiusMi;
    attributes.radiusStations = defaultRadiusStations;
    attributes.tables = [];

    this.definedCharts.push(this.createChartObject(attributes));

    attributes.title = "Total Snow";
    attributes.days = 5;
    attributes.offset = false;
    attributes.chartType = CHART_TYPES.snowDepth;
    attributes.radiusMiles = defaultRadiusMi;
    attributes.radiusStations = defaultRadiusStations;
    attributes.tables = [];

    attributes.tables.push({
      hours: 24,
    });

    attributes.tables.push({
      hours: 36,
    });

    this.definedCharts.push(this.createChartObject(attributes));

    attributes.title = "SWE";
    attributes.days = 3;
    attributes.offset = false;
    attributes.chartType = CHART_TYPES.SWE;
    attributes.radiusMiles = defaultRadiusMi;
    attributes.radiusStations = defaultRadiusStations;
    attributes.tables = [];

    attributes.tables.push({
      hours: 24,
    });

    this.definedCharts.push(this.createChartObject(attributes));
  }

  getDefinedCharts() {
    return this.definedCharts;
  }

  setDefinedCharts(chartArray) {
    this.definedCharts = chartArray;
  }

  updateDefinedChartsTables(tableList) {
    // First delete all the current tables
    this.definedCharts.forEach((currentChart) => {
      currentChart.tables = [];
    });

    // Next, iterate
    tableList.forEach((currentTable) => {
      const chartToUpdate = this.definedCharts.find(
        (myChart) => myChart.uuid === currentTable.uuid
      );
      if (chartToUpdate) {
        chartToUpdate.tables.push({ hours: currentTable.tableTime });
      } else {
        console.error("UUID missing, this should never happen");
      }
    });
  }

  pushAttributesToDefinedCharts(attributes) {
    this.setChartMode(CHART_MODES.custom);
    this.definedCharts.push(this.createChartObject(attributes));
  }

  createChartObject(attributes) {
    const fullTitle =
      attributes.title +
      " - " +
      CHART_TYPE_READABLE[attributes.chartType] +
      " - " +
      attributes.days +
      " Day" +
      addS(attributes.days);

    const chartUUID = Math.floor(Math.random() * 2 ** 32).toString(36);

    console.log("My Title: " + fullTitle);
    const tempChartObject = {
      fullTitle: fullTitle,
      title: attributes.title,
      divName:
        "weather-chart-" +
        attributes.title.substring(0, 4) +
        "-" +
        attributes.days +
        "dy-" +
        chartUUID,
      days: attributes.days,
      numHours: 24 * attributes.days,
      offset: attributes.offset,

      // The duplication of data type and chart type is dumb,
      // but I keep using them interchangably around the script and this just makes it easier :shrug:
      dataType: attributes.chartType, //See enumeration defined in const CHART_TYPES above
      chartType: attributes.chartType,
      radiusMiles: attributes.radiusMiles,
      radiusStations: attributes.radiusStations,
      tables: attributes.tables,
      uuid: chartUUID,
    };

    return tempChartObject;
  }

  getPositionAttributes() {
    return this.positionAttributes;
  }

  setPositionAttributes(
    stationMode = this.positionAttributes.stationMode,
    position = this.positionAttributes.position,
    stations = this.positionAttributes.stations
  ) {
    this.positionAttributes = {
      stationMode: stationMode,
      position: position,
      stations: stations,
    };

    // console.log(this.positionAttributes);
  }
}
