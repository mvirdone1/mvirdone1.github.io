<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Antenna Coverage KML Generator (3D wedge)</title>
  <style>
    :root { --fg:#0b1320; --muted:#5b6b88; --bg:#f7f9fc; --card:#ffffff; --accent:#2563eb; }
    *{box-sizing:border-box} body{font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:0;background:var(--bg);color:var(--fg)}
    header{padding:1.25rem 1rem;background:linear-gradient(180deg,#eef4ff,transparent)}
    h1{margin:0 0 .25rem;font-size:1.4rem} p{margin:.25rem 0;color:var(--muted)}
    .container{max-width:1100px;margin:0 auto;padding:1rem;display:grid;gap:1rem;grid-template-columns: 380px 1fr}
    .card{background:var(--card);border-radius:16px;box-shadow:0 6px 24px rgba(12,32,80,.06);padding:1rem}
    fieldset{border:none;margin:0;padding:0 0 .5rem}
    legend{font-weight:700;margin-bottom:.25rem}
    label{display:block;font-size:.9rem;color:var(--muted);margin:.6rem 0 .25rem}
    input,select{width:100%;padding:.6rem .7rem;border:1px solid #dde3ee;border-radius:10px;outline:none}
    input:focus{border-color:var(--accent);box-shadow:0 0 0 3px rgba(37,99,235,.12)}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:.6rem}
    .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:.6rem}
    .actions{display:flex;gap:.6rem;flex-wrap:wrap;margin-top:.8rem}
    button{border:none;border-radius:12px;padding:.75rem 1rem;font-weight:600;cursor:pointer}
    .primary{background:var(--accent);color:white}
    .secondary{background:#e9eefb;color:#1f3b89}
    .out{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:.9rem;white-space:pre-wrap;word-break:break-word;}
    .small{font-size:.85rem;color:var(--muted)}
    .kbd{font: 600 .8rem ui-monospace; background:#eef1f8; padding:.05rem .4rem; border-radius:6px}
    .flex{display:flex;gap:1rem;align-items:start}
    .preview{height:520px;border:1px dashed #cdd7ee;border-radius:12px;display:flex;align-items:center;justify-content:center;color:#7b8fb4;padding:1rem;text-align:center}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:1rem}
    details{background:#f3f6ff;border:1px solid #dbe6ff;border-radius:10px;padding:.6rem .8rem}
    summary{cursor:pointer;font-weight:600;color:#1b3ea7}
    code{background:#eef1f8;padding:.1rem .3rem;border-radius:6px}
  </style>
</head>
<body>
  <header>
    <div class="container" style="grid-template-columns:1fr;">
      <h1>3D Antenna Coverage → KML</h1>
      <p>Generate a KML of a 3D wedge from an antenna location, azimuth/elevation pointing, and beamwidths. Ideal for loading into Google Earth Pro.</p>
    </div>
  </header>
  <div class="container">
    <section class="card">
      <form id="form">
        <fieldset>
          <legend>Site / Antenna</legend>
          <div class="row3">
            <div>
              <label for="lat">Latitude (°)</label>
              <input id="lat" type="number" step="any" value="41.737" required />
            </div>
            <div>
              <label for="lon">Longitude (°)</label>
              <input id="lon" type="number" step="any" value="-111.833" required />
            </div>
            <div>
              <label for="alt">Antenna Altitude (m, AMSL)</label>
              <input id="alt" type="number" step="any" value="1400" required />
            </div>
          </div>
        </fieldset>

        <fieldset>
          <legend>Pointing & Beam</legend>
          <div class="row3">
            <div>
              <label for="az">Azimuth Center (° from North, CW)</label>
              <input id="az" type="number" step="any" value="0" />
            </div>
            <div>
              <label for="azBw">Azimuth Beamwidth (°)</label>
              <input id="azBw" type="number" step="any" value="60" />
            </div>
            <div>
              <label for="el">Elevation Center (° from horizon, +up)</label>
              <input id="el" type="number" step="any" value="0" />
            </div>
          </div>
          <div class="row">
            <div>
              <label for="elBw">Elevation Beamwidth (°)</label>
              <input id="elBw" type="number" step="any" value="20" />
            </div>
            <div>
              <label for="tiltNote">&nbsp;</label>
              <div class="small">Tip: Negative elevation looks downward; positive looks above horizon.</div>
            </div>
          </div>
        </fieldset>

        <fieldset>
          <legend>Range & Meshing</legend>
          <div class="row">
            <div>
              <label for="rMin">Min Range (km)</label>
              <input id="rMin" type="number" step="any" value="0" />
            </div>
            <div>
              <label for="rMax">Max Range (km)</label>
              <input id="rMax" type="number" step="any" value="20" />
            </div>
          </div>
          <div class="row">
            <div>
              <label for="azSteps">Azimuth Segments</label>
              <input id="azSteps" type="number" value="48" />
            </div>
            <div>
              <label for="elSteps">Elevation Segments</label>
              <input id="elSteps" type="number" value="8" />
            </div>
          </div>
        </fieldset>

        <fieldset>
          <legend>Output</legend>
          <div class="row">
            <div>
              <label for="name">Name</label>
              <input id="name" type="text" value="Antenna 3D Wedge" />
            </div>
            <div>
              <label for="styleColor">Color (KML aabbggrr)</label>
              <input id="styleColor" type="text" value="7dff8000" />
            </div>
          </div>
        </fieldset>

        <div class="actions">
          <button class="primary" type="button" id="gen">Generate KML</button>
          <button class="secondary" type="button" id="download" disabled>Download .kml</button>
        </div>
      </form>
      <p class="small">KML note: Google Earth cannot render true volumes; this exporter builds many small <code>&lt;Polygon&gt;</code> faces (caps + sides) with 3D vertices to visually approximate a volume.</p>
      <details>
        <summary>Advanced: math & assumptions</summary>
        <ul class="small">
          <li>Earth model: WGS‑84. Local ENU frame at antenna, convert to ECEF, then to geodetic (lat, lon, alt).</li>
          <li>Azimuth is 0° = North, increases clockwise. Elevation is +° above the horizon, −° below.</li>
          <li>Range is straight‑line slant range through air, not ground distance. Altitude = antenna_alt + r·sin(el).</li>
          <li>Min range face is skipped if set to 0 km. Increase segments for smoother arcs.</li>
        </ul>
      </details>
    </section>

    <section class="card">
      <div class="grid2">
        <div>
          <h3 style="margin-top:0">Preview (first 25 kB)</h3>
          <pre id="out" class="out preview">Nothing yet. Set parameters and click “Generate KML”.</pre>
        </div>
        <div>
          <h3 style="margin-top:0">How to use</h3>
          <ol class="small">
            <li>Enter antenna location and pointing/beam parameters.</li>
            <li>Click <span class="kbd">Generate KML</span>. Inspect the preview.</li>
            <li>Click <span class="kbd">Download .kml</span>, then open the file in Google Earth Pro or Web.</li>
            <li>Toggle transparency by editing the color (format <code>aabbggrr</code>), e.g., <code>40ff0000</code> = 25% opaque red.</li>
          </ol>
          <p class="small">Keyboard: After generating, press <span class="kbd">Ctrl/Cmd+A</span> then <span class="kbd">Ctrl/Cmd+C</span> to copy KML if you prefer.</p>
        </div>
      </div>
    </section>
  </div>

  <script>
    // === WGS84 constants ===
    const a = 6378137.0;           // semi-major
    const f = 1 / 298.257223563;   // flattening
    const b = a * (1 - f);         // semi-minor
    const e2 = 1 - (b*b)/(a*a);    // eccentricity^2

    function deg2rad(d){ return d * Math.PI / 180; }
    function rad2deg(r){ return r * 180 / Math.PI; }

    function latLonAltToECEF(latDeg, lonDeg, alt){
      const lat = deg2rad(latDeg); const lon = deg2rad(lonDeg);
      const sinLat = Math.sin(lat), cosLat = Math.cos(lat);
      const sinLon = Math.sin(lon), cosLon = Math.cos(lon);
      const N = a / Math.sqrt(1 - e2 * sinLat * sinLat);
      const x = (N + alt) * cosLat * cosLon;
      const y = (N + alt) * cosLat * sinLon;
      const z = (N*(1 - e2) + alt) * sinLat;
      return {x,y,z};
    }

    function ecefToLatLonAlt(x,y,z){
      // Bowring's method
      const ep2 = (a*a - b*b) / (b*b);
      const p = Math.sqrt(x*x + y*y);
      const th = Math.atan2(a * z, b * p);
      const lon = Math.atan2(y, x);
      const sinTh = Math.sin(th), cosTh = Math.cos(th);
      const lat = Math.atan2(z + ep2 * b * sinTh*sinTh*sinTh, p - e2 * a * cosTh*cosTh*cosTh);
      const sinLat = Math.sin(lat);
      const N = a / Math.sqrt(1 - e2 * sinLat * sinLat);
      const alt = p / Math.cos(lat) - N;
      return { lat: rad2deg(lat), lon: rad2deg(lon), alt };
    }

    function enuToEcef(e, n, u, lat0Deg, lon0Deg){
      const lat0 = deg2rad(lat0Deg), lon0 = deg2rad(lon0Deg);
      const sL = Math.sin(lat0), cL = Math.cos(lat0);
      const sO = Math.sin(lon0), cO = Math.cos(lon0);
      // ENU to ECEF rotation
      const x = -sO*e - sL*cO*n + cL*cO*u;
      const y =  cO*e - sL*sO*n + cL*sO*u;
      const z =           cL*n + sL*u;
      return {x,y,z};
    }

    function addVec(a,b){ return {x:a.x+b.x, y:a.y+b.y, z:a.z+b.z}; }

    function azElR_to_LLA(azDeg, elDeg, rKm, lat0, lon0, alt0){
      const r = rKm * 1000;
      const az = deg2rad(azDeg);
      const el = deg2rad(elDeg);
      // ENU components (azimuth measured from North, clockwise)
      const n = r * Math.cos(el) * Math.cos(az); // toward north
      const e = r * Math.cos(el) * Math.sin(az); // toward east
      const u = r * Math.sin(el);                // up
      const ecef0 = latLonAltToECEF(lat0, lon0, alt0);
      const de = enuToEcef(e, n, u, lat0, lon0);
      const ecef = addVec(ecef0, de);
      return ecefToLatLonAlt(ecef.x, ecef.y, ecef.z);
    }

    function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
    function normAz(a){ a = ((a % 360) + 360) % 360; return a; }

    function buildKml(params){
      const {lat, lon, alt, azCtr, azBw, elCtr, elBw, rMin, rMax, azSteps, elSteps, name, color} = params;
      const az0 = normAz(azCtr - azBw/2), az1 = normAz(azCtr + azBw/2);
      // handle wrap-around by mapping to monotonically increasing range
      const wrap = az1 < az0; // if true, we cross 360->0
      const azStart = az0;
      const azEnd = wrap ? az1 + 360 : az1;
      const el0 = clamp(elCtr - elBw/2, -90, 90);
      const el1 = clamp(elCtr + elBw/2, -90, 90);

      const azVals = [];
      for(let i=0;i<=azSteps;i++){ azVals.push(azStart + (azEnd-azStart)*i/azSteps); }
      const elVals = [];
      for(let j=0;j<=elSteps;j++){ elVals.push(el0 + (el1-el0)*j/elSteps); }

      function cornerLLA(azDeg){
        const a = normAz(azDeg);
        return a;
      }

      function quadPolygon(coords){
        // coords: array of {lat,lon,alt} length >= 3; ensure closed
        let s = '<Polygon><altitudeMode>absolute</altitudeMode><outerBoundaryIs><LinearRing><coordinates>';
        for(const c of coords){ s += `${c.lon.toFixed(8)},${c.lat.toFixed(8)},${c.alt.toFixed(2)}\n`; }
        // close loop
        s += `${coords[0].lon.toFixed(8)},${coords[0].lat.toFixed(8)},${coords[0].alt.toFixed(2)}\n`;
        s += '</coordinates></LinearRing></outerBoundaryIs></Polygon>';
        return s;
      }

      function cellAtRange(rKm, i, j){
        // four corners across az (i->i+1) and el (j->j+1)
        const azA = azVals[i], azB = azVals[i+1];
        const elA = elVals[j], elB = elVals[j+1];
        const p1 = azElR_to_LLA(azA, elA, rKm, lat, lon, alt);
        const p2 = azElR_to_LLA(azB, elA, rKm, lat, lon, alt);
        const p3 = azElR_to_LLA(azB, elB, rKm, lat, lon, alt);
        const p4 = azElR_to_LLA(azA, elB, rKm, lat, lon, alt);
        return [p1,p2,p3,p4];
      }

      function sideStrip(isAzFixed, idx, iFrom, iTo){
        // Build quads between rMin and rMax along the index range
        // isAzFixed: if true, vary el along fixed az = azVals[idx] (or azVals[idx+1] when at upper edge)
        // if false, vary az along fixed el = elVals[idx]
        const quads = [];
        const steps = (iTo - iFrom);
        for(let k=iFrom; k< iTo; k++){
          let a1,a2,e1,e2;
          if(isAzFixed){
            const az = (idx === -1) ? azVals[0] : (idx === 9999 ? azVals[azVals.length-1] : azVals[idx]);
            a1 = a2 = az;
            e1 = elVals[k]; e2 = elVals[k+1];
          } else {
            const el = (idx === -1) ? elVals[0] : (idx === 9999 ? elVals[elVals.length-1] : elVals[idx]);
            e1 = e2 = el;
            a1 = azVals[k]; a2 = azVals[k+1];
          }
          const p1 = azElR_to_LLA(a1, e1, rMin, lat, lon, alt);
          const p2 = azElR_to_LLA(a2, e2, rMin, lat, lon, alt);
          const p3 = azElR_to_LLA(a2, e2, rMax, lat, lon, alt);
          const p4 = azElR_to_LLA(a1, e1, rMax, lat, lon, alt);
          quads.push([p1,p2,p3,p4]);
        }
        return quads;
      }

      let kml = '';
      kml += `<?xml version="1.0" encoding="UTF-8"?>\n`;
      kml += `<kml xmlns="http://www.opengis.net/kml/2.2" xmlns:gx="http://www.google.com/kml/ext/2.2">\n`;
      kml += `<Document>\n`;
      kml += `<name>${escapeXml(name)}</name>\n`;
      kml += `<Style id="wedge"><PolyStyle><color>${color}</color><fill>1</fill><outline>0</outline></PolyStyle></Style>\n`;
      kml += `<Folder><name>${escapeXml(name)} Faces</name>\n`;

      // Caps (top and optional inner cap)
      // Top at rMax
      for(let i=0;i<azVals.length-1;i++){
        for(let j=0;j<elVals.length-1;j++){
          const quad = cellAtRange(rMax, i, j);
          kml += `<Placemark><styleUrl>#wedge</styleUrl>` + quadPolygon(quad) + `</Placemark>\n`;
        }
      }
      // Inner cap at rMin (skip if rMin == 0)
      if(rMin > 0){
        for(let i=0;i<azVals.length-1;i++){
          for(let j=0;j<elVals.length-1;j++){
            const quad = cellAtRange(rMin, i, j);
            kml += `<Placemark><styleUrl>#wedge</styleUrl>` + quadPolygon(quad) + `</Placemark>\n`;
          }
        }
      }

      // Sides (4: az=min, az=max, el=min, el=max)
      // az = min edge
      for(const quad of sideStrip(true, 0, 0, elVals.length-1)){
        kml += `<Placemark><styleUrl>#wedge</styleUrl>` + quadPolygon(quad) + `</Placemark>\n`;
      }
      // az = max edge
      for(const quad of sideStrip(true, azVals.length-1, 0, elVals.length-1)){
        kml += `<Placemark><styleUrl>#wedge</styleUrl>` + quadPolygon(quad) + `</Placemark>\n`;
      }
      // el = min edge
      for(const quad of sideStrip(false, 0, 0, azVals.length-1)){
        kml += `<Placemark><styleUrl>#wedge</styleUrl>` + quadPolygon(quad) + `</Placemark>\n`;
      }
      // el = max edge
      for(const quad of sideStrip(false, elVals.length-1, 0, azVals.length-1)){
        kml += `<Placemark><styleUrl>#wedge</styleUrl>` + quadPolygon(quad) + `</Placemark>\n`;
      }

      kml += `</Folder>\n`;
      kml += `</Document></kml>`;
      return kml;
    }

    function escapeXml(s){
      return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&apos;');
    }

    // UI wiring
    const outEl = document.getElementById('out');
    const dlBtn = document.getElementById('download');
    const genBtn = document.getElementById('gen');
    let lastBlobUrl = null;

    genBtn.addEventListener('click', () => {
      const params = {
        lat: parseFloat(document.getElementById('lat').value),
        lon: parseFloat(document.getElementById('lon').value),
        alt: parseFloat(document.getElementById('alt').value),
        azCtr: parseFloat(document.getElementById('az').value),
        azBw: parseFloat(document.getElementById('azBw').value),
        elCtr: parseFloat(document.getElementById('el').value),
        elBw: parseFloat(document.getElementById('elBw').value),
        rMin: Math.max(0, parseFloat(document.getElementById('rMin').value)),
        rMax: Math.max(0.001, parseFloat(document.getElementById('rMax').value)),
        azSteps: Math.max(1, parseInt(document.getElementById('azSteps').value)),
        elSteps: Math.max(1, parseInt(document.getElementById('elSteps').value)),
        name: document.getElementById('name').value || 'Antenna 3D Wedge',
        color: (document.getElementById('styleColor').value || '7dff8000').trim()
      };

      if(!(isFinite(params.lat)&&isFinite(params.lon)&&isFinite(params.alt))){
        alert('Please enter a valid antenna latitude/longitude/altitude.'); return;
      }
      if(!(isFinite(params.azCtr)&&isFinite(params.azBw)&&isFinite(params.elCtr)&&isFinite(params.elBw))){
        alert('Please enter valid pointing and beamwidth numbers.'); return;
      }
      if(!(isFinite(params.rMin)&&isFinite(params.rMax)) || params.rMax <= params.rMin){
        alert('Max range must be greater than min range.'); return;
      }

      const kml = buildKml(params);
      const head = kml.slice(0, 25000);
      outEl.textContent = head + (kml.length > head.length ? "\n… (truncated preview)" : "");

      const blob = new Blob([kml], {type:'application/vnd.google-earth.kml+xml'});
      if(lastBlobUrl) URL.revokeObjectURL(lastBlobUrl);
      lastBlobUrl = URL.createObjectURL(blob);
      dlBtn.disabled = false;
      dlBtn.onclick = () => {
        const a = document.createElement('a');
        a.href = lastBlobUrl;
        a.download = (params.name.replace(/\s+/g,'_') + '.kml');
        document.body.appendChild(a); a.click(); a.remove();
      };
    });
  </script>
</body>
</html>
